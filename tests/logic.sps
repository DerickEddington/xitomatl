#!r6rs
;; Copyright 2012 Derick Eddington.  My MIT-style license is in the file named
;; LICENSE from the original collection this file is distributed with.

(import
  (rnrs)
  (srfi :78 lightweight-testing)
  (xitomatl logic stream)
  (xitomatl logic)
  (xitomatl logic relations))

(define (list-of? pred) (lambda (x) (and (list? x) (for-all pred x))))


;;;; Streams (the logic system depends on them) -------------------------------

(check (force 1) => 1)
(check (force '(1)) => '(1))
(check (force (delay 1)) => 1)
(let* ((c 0)
       (p (delay (begin (set! c (+ 1 c)) #T))))
  (check c => 0)
  (let ((f (force p)))
    (check c => 1)
    (force f)
    (check c => 1)
    (force p)
    (check c => 2)))


(check (stream? '()) => #T)
(check (stream? '(1)) => #T)
(check (stream? '(1 2 3)) => #T)
(check (stream? (delay '())) => #T)
(check (stream? `(1 . ,(delay '(2 3)))) => #T)
(check (stream? `(1 2 3 . ,(delay '()))) => #T)


(check (fixed-stream) => '())
(check (stream? (fixed-stream 1)) => #T)
(check (force (fixed-stream 1)) => '(1))
(check (stream? (fixed-stream 1 2 3)) => #T)
(let ((f (force (fixed-stream 1 2 3))))
  (check (pair? f) => #T)
  (check (car f) => 1)
  (check (stream? (cdr f)) => #T)
  (check (force f) (=> eq?) f)
  (let ((f2 (force (cdr f))))
    (check (pair? f2) => #T)
    (check (car f2) => 2)
    (check (stream? (cdr f2)) => #T)
    (check (force f2) (=> eq?) f2)
    (let ((f3 (force (cdr f2))))
      (check f3 => '(3))
      (check (force f3) (=> eq?) f3))))


(check (stream->list (fixed-stream) +inf.0) => '())
(check (stream->list (fixed-stream 1) +inf.0) => '(1))
(check (stream->list (fixed-stream 1 2 3) +inf.0) => '(1 2 3))
(check (stream->list (fixed-stream 1 2 3 4 5 6 7) 4) => '(1 2 3 4))
(check (stream->list (let rec () (delay (cons 'x (rec)))) 7) => '(x x x x x x x))
(check (stream->list '() +inf.0) => '())
(check (stream->list '(1) +inf.0) => '(1))
(check (stream->list '(1 2 3) +inf.0) => '(1 2 3))
(check (stream->list '(1 2 3 4 5 6 7) 4) => '(1 2 3 4))


(define-syntax test-stream
  (syntax-rules (=>)
    ((_ limit expr => val)
     (check (stream->list expr limit) => val))
    ((_ expr => val)
     (test-stream +inf.0 expr => val))))


(check (let ((s (stream-map - (fixed-stream 1 2 3))))
         (and (not (pair? s)) (not (null? s)) (stream? s))) => #T)
(test-stream (stream-map - (fixed-stream 1 2 3)) => '(-1 -2 -3))
(test-stream (stream-map - (fixed-stream)) => '())
(test-stream 7 (stream-map - (let rec ((i 1)) (delay (cons i (rec (+ 1 i))))))
             => '(-1 -2 -3 -4 -5 -6 -7))
(let ((c 0))
  (define (s i)
    (delay (begin (set! c (+ 1 c))
                  (if (positive? i)
                    (cons i (s (- i 1)))
                    '()))))
  (stream->list (stream-map - (s 7)) +inf.0)
  (check c => 8)
  (set! c 0)
  (stream->list (stream-map - (s +inf.0)) 7)
  (check c => 7))
(check (let ((s (stream-map - '(1 2 3))))
         (and (not (pair? s)) (not (null? s)) (stream? s))) => #T)
(test-stream (stream-map - '(1 2 3)) => '(-1 -2 -3))
(test-stream (stream-map - '()) => '())


(check (let ((s (stream-append (fixed-stream 1 2 3) (fixed-stream 4 5 6 7))))
         (and (not (pair? s)) (not (null? s)) (stream? s))) => #T)
(test-stream (stream-append (fixed-stream) (fixed-stream)) => '())
(test-stream (stream-append (fixed-stream 1 2) (fixed-stream)) => '(1 2))
(test-stream (stream-append (fixed-stream) (fixed-stream 1 2)) => '(1 2))
(test-stream (stream-append (fixed-stream 1 2 3) (fixed-stream 4 5 6 7)) => '(1 2 3 4 5 6 7))
(test-stream (stream-append (fixed-stream 1 2 3) (stream-append (fixed-stream 4)
                                                                (fixed-stream 5 6 7)))
             => '(1 2 3 4 5 6 7))
(test-stream (stream-append
              (stream-append (stream-append (fixed-stream) (fixed-stream))
                             (stream-append (fixed-stream 1) (fixed-stream 2 3)))
              (stream-append (stream-append (fixed-stream)
                                            (stream-append (fixed-stream 4)
                                                           (fixed-stream)))
                             (stream-append (fixed-stream 5 6 7)
                                            (fixed-stream))))
             => '(1 2 3 4 5 6 7))
(test-stream 7 (stream-append (let rec () (delay (cons 1 (rec))))
                              (fixed-stream 2 3 4 5))
             => '(1 1 1 1 1 1 1))
(test-stream 7 (stream-append (fixed-stream 2 3 4 5)
                              (let rec () (delay (cons 1 (rec)))))
             => '(2 3 4 5 1 1 1))
(test-stream (stream-append '() '()) => '())
(test-stream (stream-append '(1) '()) => '(1))
(test-stream (stream-append '() '(1)) => '(1))
(test-stream (stream-append '(1) '(2)) => '(1 2))
(test-stream (stream-append '() (fixed-stream)) => '())
(test-stream (stream-append '(1) (fixed-stream)) => '(1))
(test-stream (stream-append '() (fixed-stream 1)) => '(1))
(test-stream (stream-append '(1) (fixed-stream 2)) => '(1 2))
(test-stream (stream-append (fixed-stream) '()) => '())
(test-stream (stream-append (fixed-stream 1) '()) => '(1))
(test-stream (stream-append (fixed-stream) '(1)) => '(1))
(test-stream (stream-append (fixed-stream 1) '(2)) => '(1 2))


(check (let ((s (stream-flatten (fixed-stream (fixed-stream 1 2) (fixed-stream 1 2)))))
         (and (not (pair? s)) (not (null? s)) (stream? s))) => #T)
(test-stream (stream-flatten (fixed-stream)) => '())
(test-stream (stream-flatten (fixed-stream (fixed-stream))) => '())
(test-stream (stream-flatten (fixed-stream (fixed-stream) (fixed-stream))) => '())
(test-stream (stream-flatten (fixed-stream (fixed-stream) (fixed-stream) (fixed-stream)))
             => '())
(test-stream (stream-flatten (fixed-stream (fixed-stream 1))) => '(1))
(test-stream (stream-flatten (fixed-stream (fixed-stream 1 2) (fixed-stream 3 4)))
             => '(1 2 3 4))
(test-stream (stream-flatten (fixed-stream (fixed-stream 1 2) (fixed-stream)
                                           (fixed-stream 3 4) (fixed-stream)
                                           (fixed-stream 5 6 7)))
             => '(1 2 3 4 5 6 7))
(test-stream (stream-flatten (fixed-stream (fixed-stream 1 (fixed-stream) 2)
                                           (fixed-stream 3 4 (fixed-stream))
                                           (fixed-stream 5 6 7)))
             => '(1 () 2 3 4 () 5 6 7))
(test-stream (stream-flatten
              (stream-flatten (fixed-stream (fixed-stream (fixed-stream 1 2)
                                                          (fixed-stream 3))
                                            (fixed-stream (fixed-stream 4)
                                                          (fixed-stream 5 6 7)))))
             => '(1 2 3 4 5 6 7))
(test-stream 7 (stream-flatten (let rec ()
                                 (delay (cons (let rec ((i 3))
                                                (delay (if (positive? i)
                                                         (cons i (rec (- i 1)))
                                                         '())))
                                              (rec)))))
             => '(3 2 1 3 2 1 3))


;;;; Logic System -------------------------------------------------------------

(define-syntax test-solve
  (syntax-rules (=>)
    ((_ limit for goal => sol ...)
     (check (solve* limit for goal)
            => `((solution . ,sol) ...)))

    ((_ for goal => sol ...)
     (test-solve +inf.0 for goal => sol ...))

    ((_ limit (for) goal (=> proc ...) expect ...)
     ; Extract a variable from the solutions, and test it with composed
     ; procedures, for all the solutions.
     (vars (for)
       (check (let* ((x (solve* limit raw goal))
                     (test (extract/procs for proc ...))
                     (expecteds (list expect ...)))
                (and (= (length x) (length expecteds))
                     (test x expecteds)))
              => #T)))

    ((_ for goal (=> proc ...) expect)
     (test-solve +inf.0 for goal (=> proc ...) expect))))

(define (extract/procs var . procs)
  (lambda (knows expecteds)
    (for-all (lambda (k e)
               (let ((x (deref* var k)))
                 (equal? e (fold-left (lambda (a p) (p a)) x procs))))
             knows expecteds)))


(test-solve () (== 1 1) => '())
(test-solve (x) (== 1 1) => '())

(test-solve () (== 1 2) =>)
(test-solve (x) (== 1 2) =>)

(test-solve () (vars (x) (== x 1)) => '())
(test-solve (x) (== x 1) => '((x = 1)))

(test-solve (x) (== x x) => '())
(test-solve () (vars (x) (== x x)) => '())

(test-solve (x) (vars (y) (== y x)) => '())

(test-solve (x y) (== x y) => '((x = y)))

(test-solve () (conj) => '())
(test-solve () (disj) =>)
(test-solve () (conj (disj (conj) (conj))
                     (disj (conj) (conj) (conj)))
            => '() '() '() '() '() '())
(test-solve () (conj (disj (conj) (conj))
                     (disj (conj) (conj) (conj))
                     (disj (conj) (conj) (conj) (conj)))
            => '() '() '() '() '() '()
               '() '() '() '() '() '()
               '() '() '() '() '() '()
               '() '() '() '() '() '())
(test-solve () (disj (conj (disj (conj) (conj))
                           (disj))
                     (disj)
                     (conj (conj))
                     (conj (disj)
                           (disj (conj) (conj))))
            => '())
(test-solve () (conj (disj (conj (disj (conj) (conj))
                                 (disj (conj) (conj)))
                           (disj (conj) (conj) (conj)))
                     (conj (disj (conj) (conj))
                           (conj))
                     (disj (conj) (conj)))
            => '() '() '() '() '() '() '() '() '() '() '() '() '() '()
               '() '() '() '() '() '() '() '() '() '() '() '() '() '())
(test-solve () (conj (disj (conj (disj (conj) (conj))
                                 (disj (conj) (conj)))
                           (disj (conj) (conj) (conj)))
                     (conj (disj (conj) (conj))
                           (conj))
                     (disj (conj) (conj))
                     (disj))
            =>)
(test-solve () (conj (disj (conj (disj (conj) (conj))
                                 (disj (conj) (conj)))
                           (disj (conj) (conj) (conj)))
                     (conj (disj (conj) (conj))
                           (conj))
                     (disj)
                     (disj (conj) (conj)))
            =>)

(test-solve (x y) (conj (== x y) (== x 1) (== y 2)) =>)
(test-solve (x y) (conj (== x 1) (== x y) (== y 2)) =>)
(test-solve (x y) (conj (== x 1) (== y 2) (== x y)) =>)
(test-solve (x y) (conj (== x y) (== 1 x) (== y 2)) =>)
(test-solve (x y) (conj (== 1 x) (== x y) (== y 2)) =>)
(test-solve (x y) (conj (== 1 x) (== y 2) (== x y)) =>)
(test-solve (x y) (conj (== x y) (== x 1) (== 2 y)) =>)
(test-solve (x y) (conj (== x 1) (== x y) (== 2 y)) =>)
(test-solve (x y) (conj (== x 1) (== 2 y) (== x y)) =>)
(test-solve (x y) (conj (== x y) (== 1 x) (== 2 y)) =>)
(test-solve (x y) (conj (== 1 x) (== x y) (== 2 y)) =>)
(test-solve (x y) (conj (== 1 x) (== 2 y) (== x y)) =>)

(test-solve () (vars (a b) (== (cons a b) (cons a b))) => '())
(test-solve () (vars (a b) (== (cons a b) (cons b a))) => '())
(test-solve () (vars (a b)
                 (conj (== (cons a b) (cons b a))
                       (== 1 a)
                       (== 2 b)))
            =>)

; TODO: conjunction and disjunction varieties
; TODO: var shadowing does not affect hygiene
; TODO: replacement of embedded variables
; TODO: all the reification aspects
(test-solve show (== 1 1) => '())
(test-solve show (== 1 2) =>)
(test-solve show (vars (x) (== x 1)) => '((x.0 = 1)))
(test-solve show (vars (x) (== x x)) => '())
(test-solve show (vars (x y z)
                   (lambda (know)
                     (define (get s) (car (stream->list s +inf.0)))
                     (fixed-stream (get ((== z 1)
                                         (get ((== y z)
                                               (get ((== y x) know)))))))))
            => '((z.2 = 1) (x.0 = z.2) (y.1 = x.0)))
(test-solve (x) (vars (y) (== x y)) => '((x = y.0)))
(test-solve (x y z) (conj (== x y) (== y z)) => '((x = z) (y = z)))
(test-solve (x y z) (conj (== y z) (== x y)) => '((x = z) (y = z)))
(test-solve (x y z) (conj (== x y) (== y z) (== z x))
            => '((x = z) (y = z)))
(test-solve (x y z) (conj (== x y) (== z x) (== y z))
            => '((x = y) (z = y)))
(test-solve (x y z) (conj (== z x) (== x y) (== y z))
            => '((x = y) (z = y)))
(test-solve (x) (vars (y z) (conj (== y x) (== y z) (== z 1)))
            => '((x = 1)))
(test-solve (w x y z) (conj (== z 1) (== y 1) (== x 1) (== w 1))
            => '((w = 1) (x = 1) (y = 1) (z = 1)))

; TODO: Tests of ?, esp when embedded
(test-solve (x) (vars (a b c)
                  (conj (== x (list a b c))
                        (== x (list ? 1 ?))
                        (== x (list 2 ? ?))
                        (== x (list ? ? 3))))
            => '((x = (2 1 3))))
(test-solve (x) (vars (a b c)
                  (conj (== x (list (list a b c)))
                        (debug-vars x a b c)
                        (== x (list (list ? 1 ?)))
                        (debug-vars x a b c)
                        (== x (list (list 2 ? ?)))
                        (debug-vars x a b c)
                        (== x (list (list ? ? 3)))
                        (debug-vars x a b c)))
            => '((x = ((2 1 3)))))


;;;; TODO Provided Relations -------------------------------------------------------

;;;; in

(test-solve () (in 1 '()) =>)
(test-solve () (in 1 '(1)) => '())
(test-solve () (in 3 '(1 2 3 4 5)) => '())
(test-solve () (in 3 '(1 3 2 3 4 3)) => '() '() '())
(test-solve () (in 7 '(1 2 3 4 5)) =>)
(test-solve (l) (conj (disj (== l '(4 5 6))
                            (== l '(1 2 3)))
                      (in 3 l))
            => '((l = (1 2 3))))
; TODO?: Can this be made to work?  Maybe be redesigning binding and/or
; dereferencing to be smarter so that the order of binding doesn't matter so
; much.
#;(test-solve (l) (conj (in 3 l)
                      (disj (== l '(4 5 6))
                            (== l '(1 2 3))))
            => '((l = (1 2 3))))
(test-solve (x) (in x '()) =>)
(test-solve (x) (in x '(1)) => '((x = 1)))
(test-solve (x) (in x '(1 2 3)) => '((x = 1)) '((x = 2)) '((x = 3)))
(test-solve (x) (conj (in x '(1 2 3 4)) (in x '(3 4 5 6))) => '((x = 3)) '((x = 4)))
(test-solve (x) (conj (in x '(1 2)) (in x '(3 4))) =>)
(test-solve (x) (in `(c ,x ,?) `((a 1 2) (,? 3 4))) => '((x = 3)))
(test-solve (x) (in `(c ,x ,?) '((a 1 2) (b 3 4) (c 5 6))) => '((x = 5)))
(test-solve (x y) (vars (z)
                    (conj (in z (list x y))
                          (== z 1)))
            => '((x = 1)) '((y = 1)))


;;;; all

(test-solve () (all 1 '()) => '())
(test-solve () (all 1 '(1)) => '())
(test-solve () (all 1 '(1 1)) => '())
(test-solve () (all 1 '(1 1 1 1)) => '())
(test-solve () (all 1 '(1 1 2 1)) =>)
(test-solve () (all ? '()) => '())
(test-solve () (all ? '(1)) => '())
(test-solve () (all ? '(1 1)) => '())
(test-solve () (all ? '(1 1 1 1)) => '())
(test-solve () (all ? '(1 1 2 1)) => '())
(test-solve (x) (all x '()) => '())
(test-solve (x) (all x '(1)) => '((x = 1)))
(test-solve (x) (all x '(1 1)) => '((x = 1)))
(test-solve (x) (all x '(1 1 1 1)) => '((x = 1)))
(test-solve (x) (all x '(1 1 2 1)) =>)
(test-solve () (vars (x) (conj (== x 1) (all x '()))) => '())
(test-solve () (vars (x) (conj (== x 1) (all x '(1)))) => '())
(test-solve () (vars (x) (conj (== x 1) (all x '(1 1)))) => '())
(test-solve () (vars (x) (conj (== x 1) (all x '(1 1 1 1)))) => '())
(test-solve () (vars (x) (conj (== x 1) (all x '(1 1 2 1)))) =>)
(test-solve () (vars (x) (conj (all x '()) (== x 1))) => '())
(test-solve () (vars (x) (conj (all x '(1)) (== x 1))) => '())
(test-solve () (vars (x) (conj (all x '(1 1)) (== x 1))) => '())
(test-solve () (vars (x) (conj (all x '(1 1 1 1)) (== x 1))) => '())
(test-solve () (vars (x) (conj (all x '(1 1 2 1)) (== x 1))) =>)
(test-solve 5 (x) (all 1 x) => '((x = ())) '((x = (1))) '((x = (1 1)))
                               '((x = (1 1 1))) '((x = (1 1 1 1))))


;;;; some
; TODO


;;;; concat
;TODO


;;;; size

(define list-1e6 (vector->list (make-vector #e1e6)))

(test-solve () (size '() 0) => '())
(test-solve () (size '(x) 1) => '())
(test-solve () (size '(x x) 2) => '())
(test-solve () (size '(x x x) 3) => '())
(test-solve () (size list-1e6 #e1e6) => '())
(test-solve () (size '() 1) =>)
(test-solve () (size '(x) 2) =>)
(test-solve () (size '(x x) 1) =>)
(test-solve () (size '(x x x) 7) =>)
(test-solve () (size list-1e6 (+ #e1e6 1)) =>)

(test-solve (a) (size '() a) => '((a = 0)))
(test-solve (a) (size '(x) a) => '((a = 1)))
(test-solve (a) (size '(x x) a) => '((a = 2)))
(test-solve (a) (size '(x x x) a) => '((a = 3)))
(test-solve (a) (size '(x x x x x x x) a) => '((a = 7)))
(test-solve (a) (size list-1e6 a) => '((a = #e1e6)))

(test-solve (a) (size a 0) => '((a = ())))
(test-solve (a) (size a 1) (=> (list-of? var?)) #T)
(test-solve (a) (size a 1) (=> length) 1)
(test-solve (a) (size a 2) (=> (list-of? var?)) #T)
(test-solve (a) (size a 2) (=> length) 2)
(test-solve (a) (size a 3) (=> (list-of? var?)) #T)
(test-solve (a) (size a 3) (=> length) 3)
(test-solve (a) (size a 7) (=> (list-of? var?)) #T)
(test-solve (a) (size a 7) (=> length) 7)
(test-solve (a) (size a #e1e6) (=> (list-of? var?)) #T)
(test-solve (a) (size a #e1e6) (=> length) #e1e6)

(test-solve (a) (vars (r)
                  (conj (== r '(3 4 5))
                        (size `(1 2 . ,r) a)))
            => '((a = 5)))
(test-solve (a) (vars (b c d)
                  (conj (== b `(1 . ,c))
                        (== c `(2 . ,d))
                        (== d '())
                        (size b a)))
            => '((a = 2)))
(test-solve (a) (size `(1 2 . ,a) 5) => '((a = (?.2 ?.1 ?.0))))
(test-solve 4 (a b) (size `(1 2 . ,a) b) => '((a = ()) (b = 2))
                                            '((a = (?.0)) (b = 3))
                                            '((a = (?.1 ?.0)) (b = 4))
                                            '((a = (?.2 ?.1 ?.0)) (b = 5)))


;;;; right-of (and so left-of)

(test-solve () (right-of 2 1 '(1 2)) => '())
(test-solve () (right-of 1 2 '(1 2)) =>)
(test-solve () (right-of 1 2 '(1)) =>)
(test-solve () (right-of 2 1 '(1)) =>)
(test-solve () (right-of 1 2 '()) =>)
(test-solve () (right-of 2 1 '()) =>)
(test-solve () (right-of 4 3 '(1 2 3 4 5 6 7)) => '())
(test-solve () (right-of 3 4 '(1 2 3 4 5 6 7)) =>)
(test-solve () (vars (l)
                 (conj (== l '(1 2 3 1 4 5 1))
                       (right-of 1 3 l)
                       (right-of 1 5 l)))
            => '())
(test-solve () (vars (l)
                 (conj (== l '(1 2 3 1 4 5 1))
                       (right-of 1 3 l)
                       (right-of 1 0 l)))
            => )
(test-solve (x) (right-of x 1 '(1 2 3 4 5 6 7)) => '((x = 2)))
(test-solve (x) (right-of x 2 '(1 2 3 4 5 6 7)) => '((x = 3)))
(test-solve (x) (right-of x 4 '(1 2 3 4 5 6 7)) => '((x = 5)))
(test-solve (x) (right-of x 7 '(1 2 3 4 5 6 7)) =>)
(test-solve (x) (right-of x 1 '(1 2 3 1 4 5 1)) => '((x = 2)) '((x = 4)))
(test-solve (x) (right-of x 2 '(1 2 3 2 4 5 2)) => '((x = 3)) '((x = 4)))
(test-solve (x) (right-of x 4 '(1 2 4 4 5 6 4)) => '((x = 4)) '((x = 5)))
(test-solve (x) (right-of x 7 '(7 1 7 3 7 4 7)) => '((x = 1)) '((x = 3)) '((x = 4)))
(test-solve (x) (right-of 1 x '(1 2 3 4 5 6 7)) =>)
(test-solve (x) (right-of 2 x '(1 2 3 4 5 6 7)) => '((x = 1)))
(test-solve (x) (right-of 4 x '(1 2 3 4 5 6 7)) => '((x = 3)))
(test-solve (x) (right-of 7 x '(1 2 3 4 5 6 7)) => '((x = 6)))
(test-solve (x) (right-of 1 x '(1 2 3 1 4 5 1)) => '((x = 3)) '((x = 5)))
(test-solve (x) (right-of 2 x '(1 2 3 2 4 5 2)) => '((x = 1)) '((x = 3)) '((x = 5)))
(test-solve (x) (right-of 4 x '(1 2 4 4 5 6 4)) => '((x = 2)) '((x = 4)) '((x = 6)))
(test-solve (x) (right-of 7 x '(7 1 7 3 7 4 7)) => '((x = 1)) '((x = 3)) '((x = 4)))
(test-solve (x y) (right-of x y '(1 2 3 4 5 6 7))
            => '((x = 2) (y = 1))
               '((x = 3) (y = 2))
               '((x = 4) (y = 3))
               '((x = 5) (y = 4))
               '((x = 6) (y = 5))
               '((x = 7) (y = 6)))
(test-solve (x) (right-of 2 x '(1 2 3 2 5 2 7)) => '((x = 1)) '((x = 3)) '((x = 5)))
(test-solve (x) (right-of x 2 '(1 2 3 2 5 2 7)) => '((x = 3)) '((x = 5)) '((x = 7)))
(test-solve () (vars (x y) (right-of x y (list y x))) => '())
(test-solve () (vars (x y) (right-of x y (list x y))) => '())
(test-solve () (vars (x y)
                 (conj (right-of x y (list x y))
                       (== x y)))
            => '())
(test-solve () (vars (x y)
                 (conj (right-of x y (list x y))
                       (== x 1)
                       (== y 2)))
            =>)
(test-solve () (vars (x y) (right-of x y (list 1 2 y x 3 4))) => '() '() '() '() '())
(test-solve (x y) (conj (right-of x y (list 1 2 y x 3 4))
                        (== x y))
            => '((x = 2) (y = 2)) '((x = y)) '((x = 3) (y = 3)))
(test-solve () (vars (x y) (right-of x y (list 1 2 x y 3 4))) => '() '() '() '() '())
(test-solve (x y) (conj (right-of x y (list 1 2 x y 3 4))
                        (== x y))
            => '((x = 2) (y = 2)) '((y = x)) '((x = 3) (y = 3)))
(test-solve () (vars (x y) (right-of x y `(1 2 ,x 4 5))) => '() '() '() '())
(test-solve () (vars (x y) (right-of x y `(1 2 ,y 4 5))) => '() '() '() '())
(test-solve () (right-of '(5 6) '(3 4) '((1 2) (3 4) (5 6) (7 8))) => '())
(test-solve (x) (right-of x '(5 6) '((1 2) (3 4) (5 6) (7 8))) => '((x = (7 8))))
(test-solve (x) (right-of x '(7 8) '((1 2) (3 4) (5 6) (7 8))) =>)
(test-solve (x) (right-of '(1 2) x '((1 2) (3 4) (5 6) (7 8))) =>)
(test-solve (x) (right-of '(7 8) x '((1 2) (3 4) (5 6) (7 8))) => '((x = (5 6))))
(test-solve 1 (x) (right-of 2 1 x) => '((x = (1 2 . ?.0))))
(test-solve 3 (x) (right-of 2 1 x) => '((x = (1 2 . ?.0)))
                                      '((x = (?.1 1 2 . ?.3)))
                                      '((x = (?.1 ?.4 1 2 . ?.5))))


;;;; next-to

(test-solve () (next-to 1 2 '()) =>)
(test-solve () (next-to 1 2 '(1 2)) => '())
(test-solve () (next-to 1 2 '(2 1)) => '())
(test-solve () (next-to 3 4 '(1 2 3 4 5 6 7)) => '())
(test-solve () (next-to 6 5 '(7 6 5 4 3 2 1)) => '())
(test-solve (x) (next-to x 2 '(1 2 3)) => '((x = 1)) '((x = 3)))
(test-solve (x) (next-to 2 x '(1 2 3)) => '((x = 3)) '((x = 1)))
(test-solve (x y) (next-to x y '(1 2 3))
            => '((x = 1) (y = 2)) '((x = 2) (y = 3))
               '((x = 2) (y = 1)) '((x = 3) (y = 2)))


;;;; middle

(test-solve () (middle 1 '()) =>)
(test-solve () (middle 1 '(1)) => '())
(test-solve () (middle 1 '(2)) =>)
(test-solve () (middle 1 '(1 2 3)) =>)
(test-solve () (middle 2 '(1 2 3)) => '())
(test-solve () (middle 3 '(1 2 3)) =>)
(test-solve () (middle 3 '(1 2 3 4 5 6 7)) =>)
(test-solve () (middle 4 '(1 2 3 4 5 6 7)) => '())
(test-solve () (middle 5 '(1 2 3 4 5 6 7)) =>)
(test-solve (x) (middle x '()) =>)
(test-solve (x) (middle x '(1)) => '((x = 1)))
(test-solve (x) (middle x '(1 2)) =>)
(test-solve (x) (middle x '(1 2 3)) => '((x = 2)))
(test-solve (x) (middle x '(1 2 3 4 5 6)) =>)
(test-solve (x) (middle x '(1 2 3 4 5 6 7)) => '((x = 4)))
(test-solve (x) (conj (disj (== x '(1 2 3))
                            (== x '(1 2 3 4 5)))
                      (middle 3 x))
            => '((x = (1 2 3 4 5))))
(test-solve (x) (vars (l)
                  (conj (disj (== l '(1 2 3))
                              (== l '(1 2 3 4 5)))
                        (middle x l)))
            => '((x = 2)) '((x = 3)))
(test-solve 4 (x) (middle 'm x) (=> list?) #T #T #T #T)
(test-solve 4 (x) (middle 'm x) (=> length) 1 3 5 7)
(test-solve 4 (x) (middle 'm x)
            (=> (lambda (x) (list-ref x (/ (- (length x) 1) 2))))
            'm 'm 'm 'm)


;;;; less (and so greater)

(test-solve () (less 0 0) =>)
(test-solve () (less 0 1) => '())
(test-solve () (less 1 2) => '())
(test-solve () (less 1 3) => '())
(test-solve () (less 1 987) => '())
(test-solve () (less 2 0) =>)
(test-solve () (less 2 1) =>)
(test-solve () (less 2 2) =>)
(test-solve () (less 2 3) => '())
(test-solve () (less 2 987) => '())
(test-solve () (less 987 0) =>)
(test-solve () (less 987 3) =>)
(test-solve () (less 987 987) =>)
(test-solve () (less 987 988) => '())
(test-solve () (less 987 (expt 2 17)) => '())
(test-solve () (less ? 0) =>)
(test-solve () (less ? 1) => '())
(test-solve () (less ? 2) => '() '())
(test-solve () (less ? 3) => '() '() '())
(check (length (solve () (less ? 987))) => 987)
(test-solve (a) (less a 0) =>)
(test-solve (a) (less a 1) => '((a = 0)))
(test-solve (a) (less a 2) => '((a = 0)) '((a = 1)))
(test-solve (a) (less a 3) => '((a = 0)) '((a = 1)) '((a = 2)))
(check (length (solve (a) (less a 987))) => 987)
(test-solve 4 (b) (less 0 b) => '((b = 1)) '((b = 2)) '((b = 3)) '((b = 4)))
(test-solve 4 (b) (less 1 b) => '((b = 2)) '((b = 3)) '((b = 4)) '((b = 5)))
(test-solve 4 (b) (less 2 b) => '((b = 3)) '((b = 4)) '((b = 5)) '((b = 6)))
(test-solve 4 (b) (less 3 b) => '((b = 4)) '((b = 5)) '((b = 6)) '((b = 7)))
(check (length (solve* 1000 (b) (less 987 b))) => 1000)
(test-solve 10 (a b) (less a b) => '((a = 0) (b = 1))
                                   '((a = 0) (b = 2))
                                   '((a = 1) (b = 2))
                                   '((a = 0) (b = 3))
                                   '((a = 1) (b = 3))
                                   '((a = 2) (b = 3))
                                   '((a = 0) (b = 4))
                                   '((a = 1) (b = 4))
                                   '((a = 2) (b = 4))
                                   '((a = 3) (b = 4)))
(check (length (solve* 1000 (a b) (less a b))) => 1000)
(test-solve (a) (vars (b) (conj (== b 3) (less a b))) => '((a = 0)) '((a = 1)) '((a = 2)))
(test-solve 3 (a) (vars (b) (conj (less a b) (== b 3))) => '((a = 0)) '((a = 1)) '((a = 2)))
(test-solve 3 (b) (vars (a) (conj (== a 3) (less a b))) => '((b = 4)) '((b = 5)) '((b = 6)))
(test-solve 3 (b) (vars (a) (conj (less a b) (== a 3))) => '((b = 4)) '((b = 5)) '((b = 6)))


;;;; plus (and so minus)

(test-solve () (plus 0 0 0) => '())
(test-solve () (plus 0 1 1) => '())
(test-solve () (plus 1 0 1) => '())
(test-solve () (plus 1 1 2) => '())
(test-solve () (plus 1 2 3) => '())
(test-solve () (plus 0 0 1) =>)
(test-solve () (plus 0 1 0) =>)
(test-solve () (plus 1 1 0) =>)

(test-solve () (plus ? 1 0) =>)
(test-solve () (plus 1 ? 0) =>)
(test-solve () (plus ? 3 0) =>)
(test-solve () (plus 3 ? 0) =>)

(test-solve 5 (a) (plus a 0 a) => '((a = 0)) '((a = 1)) '((a = 2)) '((a = 3)) '((a = 4)))
(test-solve 5 (b) (plus 0 b b) => '((b = 0)) '((b = 1)) '((b = 2)) '((b = 3)) '((b = 4)))
(test-solve (a) (plus a a a) => '((a = 0)))
(test-solve (a) (plus a 1 a) =>)
(test-solve (b) (plus 1 b b) =>)
(test-solve (a) (plus a 3 a) =>)
(test-solve (b) (plus 3 b b) =>)

(test-solve (a) (plus a a 0) => '((a = 0)))
(test-solve (a) (plus a 4 7) => '((a = 3)))
(test-solve (a) (plus 3 a 7) => '((a = 4)))
(test-solve (a) (plus 3 4 a) => '((a = 7)))
(test-solve (a) (plus a 7654 11975) => '((a = 4321)))
(test-solve (a) (plus 4321 a 11975) => '((a = 7654)))
(test-solve (a) (plus 4321 7654 a) => '((a = 11975)))

(test-solve (a b) (plus a b 0) => '((a = 0) (b = 0)))
(test-solve (a b) (plus a b 1) => '((a = 0) (b = 1)) '((a = 1) (b = 0)))
(test-solve (a b) (plus a b 2) => '((a = 0) (b = 2)) '((a = 1) (b = 1)) '((a = 2) (b = 0)))
(test-solve (a b) (plus a b 4) => '((a = 0) (b = 4)) '((a = 1) (b = 3))
                                  '((a = 2) (b = 2)) '((a = 3) (b = 1)) '((a = 4) (b = 0)))
(test-solve 3 (a b) (plus a b 11975) => '((a = 0) (b = 11975))
                                        '((a = 1) (b = 11974))
                                        '((a = 2) (b = 11973)))
(check (length (solve (a b) (plus a b 1000))) => 1001)

(test-solve 3 (a c) (plus a 0 c) => '((a = 0) (c = 0)) '((a = 1) (c = 1)) '((a = 2) (c = 2)))
(test-solve 3 (a c) (plus a 1 c) => '((a = 0) (c = 1)) '((a = 1) (c = 2)) '((a = 2) (c = 3)))
(test-solve 3 (a c) (plus a 2 c) => '((a = 0) (c = 2)) '((a = 1) (c = 3)) '((a = 2) (c = 4)))
(test-solve 3 (a c) (plus a 4 c) => '((a = 0) (c = 4)) '((a = 1) (c = 5)) '((a = 2) (c = 6)))
(test-solve 3 (a c) (plus a 11975 c) => '((a = 0) (c = 11975))
                                        '((a = 1) (c = 11976))
                                        '((a = 2) (c = 11977)))
(check (length (solve* 1000 (a c) (plus a 3 c))) => 1000)

(test-solve 3 (b c) (plus 0 b c) => '((b = 0) (c = 0)) '((b = 1) (c = 1)) '((b = 2) (c = 2)))
(test-solve 3 (b c) (plus 1 b c) => '((b = 0) (c = 1)) '((b = 1) (c = 2)) '((b = 2) (c = 3)))
(test-solve 3 (b c) (plus 2 b c) => '((b = 0) (c = 2)) '((b = 1) (c = 3)) '((b = 2) (c = 4)))
(test-solve 3 (b c) (plus 4 b c) => '((b = 0) (c = 4)) '((b = 1) (c = 5)) '((b = 2) (c = 6)))
(test-solve 3 (b c) (plus 11975 b c) => '((b = 0) (c = 11975))
                                        '((b = 1) (c = 11976))
                                        '((b = 2) (c = 11977)))
(check (length (solve* 1000 (b c) (plus 3 b c))) => 1000)

(test-solve 15 (a b c) (plus a b c) => '((a = 0) (b = 0) (c = 0))
                                       '((a = 0) (b = 1) (c = 1))
                                       '((a = 1) (b = 0) (c = 1))
                                       '((a = 0) (b = 2) (c = 2))
                                       '((a = 1) (b = 1) (c = 2))
                                       '((a = 2) (b = 0) (c = 2))
                                       '((a = 0) (b = 3) (c = 3))
                                       '((a = 1) (b = 2) (c = 3))
                                       '((a = 2) (b = 1) (c = 3))
                                       '((a = 3) (b = 0) (c = 3))
                                       '((a = 0) (b = 4) (c = 4))
                                       '((a = 1) (b = 3) (c = 4))
                                       '((a = 2) (b = 2) (c = 4))
                                       '((a = 3) (b = 1) (c = 4))
                                       '((a = 4) (b = 0) (c = 4)))
(test-solve 10 (a c) (plus a a c) => '((a = 0) (c = 0))
                                     '((a = 1) (c = 2))
                                     '((a = 2) (c = 4))
                                     '((a = 3) (c = 6))
                                     '((a = 4) (c = 8))
                                     '((a = 5) (c = 10))
                                     '((a = 6) (c = 12))
                                     '((a = 7) (c = 14))
                                     '((a = 8) (c = 16))
                                     '((a = 9) (c = 18)))

(test-solve 10 (a c) (vars (b) (conj (== a b) (plus a b c))) => '((a = 0) (c = 0))
                                                                '((a = 1) (c = 2))
                                                                '((a = 2) (c = 4))
                                                                '((a = 3) (c = 6))
                                                                '((a = 4) (c = 8))
                                                                '((a = 5) (c = 10))
                                                                '((a = 6) (c = 12))
                                                                '((a = 7) (c = 14))
                                                                '((a = 8) (c = 16))
                                                                '((a = 9) (c = 18)))
(test-solve 10 (a c) (vars (b) (conj (plus a b c) (== a b))) => '((a = 0) (c = 0))
                                                                '((a = 1) (c = 2))
                                                                '((a = 2) (c = 4))
                                                                '((a = 3) (c = 6))
                                                                '((a = 4) (c = 8))
                                                                '((a = 5) (c = 10))
                                                                '((a = 6) (c = 12))
                                                                '((a = 7) (c = 14))
                                                                '((a = 8) (c = 16))
                                                                '((a = 9) (c = 18)))

(test-solve 10 (a c) (vars (b) (conj (plus a 3 b) (plus a b c))) => '((a = 0) (c = 3))
                                                                    '((a = 1) (c = 5))
                                                                    '((a = 2) (c = 7))
                                                                    '((a = 3) (c = 9))
                                                                    '((a = 4) (c = 11))
                                                                    '((a = 5) (c = 13))
                                                                    '((a = 6) (c = 15))
                                                                    '((a = 7) (c = 17))
                                                                    '((a = 8) (c = 19))
                                                                    '((a = 9) (c = 21)))
(test-solve 10 (a c) (vars (b) (conj (plus a b c) (plus a 3 b))) => '((a = 0) (c = 3))
                                                                    '((a = 1) (c = 5))
                                                                    '((a = 2) (c = 7))
                                                                    '((a = 3) (c = 9))
                                                                    '((a = 4) (c = 11))
                                                                    '((a = 5) (c = 13))
                                                                    '((a = 6) (c = 15))
                                                                    '((a = 7) (c = 17))
                                                                    '((a = 8) (c = 19))
                                                                    '((a = 9) (c = 21)))

(test-solve (c) (vars (b) (conj (== b 0) (plus 1 b c))) => '((c = 1)))
(test-solve (c) (vars (b) (conj (== b 1) (plus 1 b c))) => '((c = 2)))
(test-solve (c) (vars (a) (conj (== a 0) (plus a 1 c))) => '((c = 1)))
(test-solve (a) (vars (c) (conj (== c 0) (plus a 1 c))) =>)
(test-solve (b) (vars (c) (conj (== c 0) (plus 1 b c))) =>)
(test-solve (a) (vars (c) (conj (== c 1) (plus a 1 c))) => '((a = 0)))
(test-solve (b) (vars (c) (conj (== c 1) (plus 1 b c))) => '((b = 0)))

(test-solve 1 (c) (vars (b) (conj (plus 1 b c) (== b 0))) => '((c = 1)))
(test-solve 1 (c) (vars (b) (conj (plus 1 b c) (== b 1))) => '((c = 2)))
(test-solve 1 (c) (vars (a) (conj (plus a 1 c) (== a 0))) => '((c = 1)))
#;(test-solve N (a) (vars (c) (conj (plus a 1 c) (== c 0))) =>) ; non-terminating
#;(test-solve N (b) (vars (c) (conj (plus 1 b c) (== c 0))) =>) ; non-terminating
(test-solve 1 (a) (vars (c) (conj (plus a 1 c) (== c 1))) => '((a = 0)))
(test-solve 1 (b) (vars (c) (conj (plus 1 b c) (== c 1))) => '((b = 0)))

; TODO: more enumerating of possible solutions

(test-solve 5 (a b c d) (conj (plus a d c)
                              (plus a a b)
                              (plus b 100 c))
            => '((a = 0) (b = 0) (c = 100) (d = 100))
               '((a = 1) (b = 2) (c = 102) (d = 101))
               '((a = 2) (b = 4) (c = 104) (d = 102))
               '((a = 3) (b = 6) (c = 106) (d = 103))
               '((a = 4) (b = 8) (c = 108) (d = 104)))

(test-solve 1 (a b c) (vars (d)
                        (conj (== d 41)
                              (plus a 10 b)
                              (plus a b c)
                              (plus b c d)))
            => '((a = 7) (b = 17) (c = 24)))
(test-solve 1 (a b c) (vars (d)
                        (conj (plus a 10 b)
                              (plus a b c)
                              (plus b c d)
                              (== d 41)))
            => '((a = 7) (b = 17) (c = 24)))
(test-solve 1 (b c) (vars (a d)
                      (conj (plus a 10 b)
                            (== a 7)
                            (plus a b c)
                            (plus b c d)
                            (== d 41)))
            => '((b = 17) (c = 24)))
(test-solve (b c) (vars (a d)
                    (conj (== a 7)
                          (plus a 10 b)
                          (plus a b c)
                          (plus b c d)
                          (== d 41)))
            => '((b = 17) (c = 24)))

(test-solve (a b c d) (conj (less a 8)
                            (less 4 a)
                            (plus a 10 b)
                            (plus a b c)
                            (plus b c d))
            => '((a = 5) (b = 15) (c = 20) (d = 35))
               '((a = 6) (b = 16) (c = 22) (d = 38))
               '((a = 7) (b = 17) (c = 24) (d = 41)))
(test-solve 3 (a b c d) (conj (less 4 a)
                              (less a 8)
                              (plus a 10 b)
                              (plus a b c)
                              (plus b c d))
            => '((a = 5) (b = 15) (c = 20) (d = 35))
               '((a = 6) (b = 16) (c = 22) (d = 38))
               '((a = 7) (b = 17) (c = 24) (d = 41)))


;;;; Examples TODO like Nine Queens, etc.

;;;; Zebra --------------------------------------------------------------------
;
; Given the following facts:
; 1. There are five houses in a row, each of a different color and inhabited by
; men of different nationalities, with different pets, drinks, and cigarettes.
; 2. The Englishman lives in the red house.
; 3. The Spaniard owns a dog.
; 4. Coffee is drunk in the green house.
; 5. The Ukrainian drinks tea.
; 6. The Old Gold smoker owns snails.
; 7. Kools are being smoked in the yellow house.
; 8. The green house is directly to the right of the ivory house.
; 9. Milk is drunk in the middle house.
; 10. The Norwegian lives in the first house on the left.
; 11. The Chesterfield smoker lives next to the fox owner.
; 12. Kools are smoked in the house next to the house where the horse is kept.
; 13. The Lucky Strike smoker drinks orange juice.
; 14. The Japanese smokes Parliaments.
; 15. The Norwegian lives next to the blue house.
; Determine what man owns the zebra.

(define (left-most x l)
  (== (cons x ?) l))

(test-solve () (left-most 1 '()) =>)
(test-solve () (left-most 1 '(1)) => '())
(test-solve () (left-most 1 '(1 2 3 4 5)) => '())
(test-solve () (left-most 2 '(1 2 3 4 5)) =>)
(test-solve (x) (left-most x '()) =>)
(test-solve (x) (left-most x '(1)) => '((x = 1)))
(test-solve (x) (left-most x '(1 2 3 4 5)) => '((x = 1)))
(test-solve (x) (conj (left-most x '(1 2 3 4 5)) (== x 2)) =>)
(test-solve (x) (conj (left-most 3 x)
                      (disj (== x '(1 2 3))
                            (== x '(3 4))))
            => '((x = (3 4))))

(define (zebra row)
  (conj (== row `((,? ,? ,? ,? ,?)
                  (,? ,? ,? ,? ,?)
                  (,? ,? ,? ,? ,?)
                  (,? ,? ,? ,? ,?)
                  (,? ,? ,? ,? ,?)))
        (in `(red english ,? ,? ,?) row)
        (in `(,? spanish dog ,? ,?) row)
        (in `(green ,? ,? coffee ,?) row)
        (in `(,? ukrainian ,? tea ,?) row)
        (in `(,? ,? snails ,? old-gold) row)
        (in `(yellow ,? ,? ,? kool) row)
        (right-of `(green ,? ,? ,? ,?) `(ivory ,? ,? ,? ,?) row)
        (middle `(,? ,? ,? milk ,?) row)
        (left-most `(,? norwegian ,? ,? ,?) row)
        (next-to `(,? ,? ,? ,? chesterfield) `(,? ,? fox ,? ,?) row)
        (next-to `(,? ,? ,? ,? kool) `(,? ,? horse ,? ,?) row)
        (in `(,? ,? ,? orange-juice lucky-strike) row)
        (in `(,? japanese ,? ,? parliament) row)
        (next-to `(,? norwegian ,? ,? ,?) `(blue ,? ,? ,? ,?) row)))

(test-solve (owner row)
  (conj (zebra row)
        (in `(,? ,owner zebra ,? ,?) row)
        (in `(,? ,? ,? water ,?) row))
  => '((owner = japanese)
       (row = ((yellow norwegian fox water kool)
               (blue ukrainian horse tea chesterfield)
               (red english snails milk old-gold)
               (ivory spanish dog orange-juice lucky-strike)
               (green japanese zebra coffee parliament)))))


;;;; Towers of Hanoi ----------------------------------------------------------
;
; It consists of three rods, and a number of disks of different sizes which can
; slide onto any rod. The puzzle starts with the disks in a neat stack in
; ascending order of size on one rod, the smallest at the top, thus making a
; conical shape.
; The objective of the puzzle is to move the entire stack to another rod,
; obeying the following rules:
; - Only one disk may be moved at a time.
; - Each move consists of taking the upper disk from one of the rods and sliding
;   it onto another rod, on top of the other disks that may already be present
;   on that rod.
; - No disk may be placed on top of a smaller disk.
;
; The sequence of moves is represented as a list where an element is a state and
; the order is the sequence of moves.  The state is represented as a list where
; an element is a stack of disks, and a stack of disks is represented as a list
; where an element is a disk, and a disk is represented as a natural number.
; E.g. a state: ((1 2 3) () ())

(define (rods n state) (conj (size state n) (greater n 0)))

(test-solve () (rods 4 (list ? ? ? ?)) => '())
(test-solve (s) (rods 0 s) =>)
(test-solve (s) (rods 1 s) => '((s = (?.0))))
(test-solve (s) (rods 4 s) => '((s = (?.3 ?.2 ?.1 ?.0))))
(test-solve (n) (rods n '()) =>)
(test-solve (n) (rods n (list ?)) => '((n = 1)))
(test-solve (n) (rods n (list ? ? ? ?)) => '((n = 4)))
(test-solve () (rods 0 '()) =>)
(test-solve () (rods 0 (list ?)) =>)
(test-solve () (rods 1 '()) =>)
(test-solve () (rods 1 (list ?)) => '())
(test-solve () (rods 1 (list ? ?)) =>)
(test-solve () (rods 4 '()) =>)
(test-solve () (rods 4 (list ? ? ?)) =>)
(test-solve () (rods 4 (list ? ? ? ? ?)) =>)
(test-solve 5 (n s) (rods n s) => '((n = 1) (s = (?.0)))
                                  '((n = 2) (s = (?.1 ?.0)))
                                  '((n = 3) (s = (?.2 ?.1 ?.0)))
                                  '((n = 4) (s = (?.3 ?.2 ?.1 ?.0)))
                                  '((n = 5) (s = (?.4 ?.3 ?.2 ?.1 ?.0))))

(define (disks n state)
  ; Initial and final state is an ordered stack on only one rod.
  (define (stack v n)
    (disj (conj (== n 0) (== v '()))
          (vars (s n*)
            (conj (minus n 1 n*)
                  (stack s n*)
                  (concat s (list n) v)))))
  (vars (sk sz)
    (conj (greater n 0)
          (stack sk n)
          (disj (less sz n) (== sz n))
          (size state sz)
          (let rec ((state state))
            (vars (a r)
              (conj (== state (cons a r))
                    (disj (conj (== a sk)
                                (all '() r))
                          (conj (== a '())
                                (rec r)))))))))

(test-solve () (disks 0 '()) =>)
(test-solve () (disks 0 (list ?)) =>)
(test-solve () (disks 0 (list ? ? ? ?)) =>)
(test-solve () (disks 1 '()) =>)
(test-solve () (disks 1 '((1))) => '())
(test-solve () (disks 1 `((1) ,?)) =>)
(test-solve () (disks 1 `((1) ,? ,?)) =>)
(test-solve () (disks 1 `((1) ,? ,? ,? ,?)) =>)
(test-solve () (disks 1 '((1 2))) =>)
(test-solve () (disks 1 '((1) (2))) =>)
(test-solve () (disks 2 '()) =>)
(test-solve () (disks 2 '((1 2))) => '())
(test-solve () (disks 2 `((1 2) ,?)) => '())
(test-solve () (disks 2 `((1 2) ,? ,?)) =>)
(test-solve () (disks 2 `((1 2) ,? ,? ,? ,?)) =>)
(test-solve () (disks 2 '((1))) =>)
(test-solve () (disks 2 '((2))) =>)
(test-solve () (disks 2 '((2 1))) =>)
(test-solve () (disks 2 '((1 2 3))) =>)
(test-solve () (disks 2 '((2) (1))) =>)
(test-solve () (disks 4 '()) =>)
(test-solve () (disks 4 '((1 2 3 4))) => '())
(test-solve () (disks 4 `((1 2 3 4) ,?)) => '())
(test-solve () (disks 4 `((1 2 3 4) ,? ,?)) => '())
(test-solve () (disks 4 `((1 2 3 4) ,? ,? ,?)) => '())
(test-solve () (disks 4 `((1 2 3 4) ,? ,? ,? ,?)) =>)
(test-solve () (disks 4 '((1 2 3))) =>)
(test-solve () (disks 4 '((3 4) (2) (1))) =>)
(test-solve () (disks 4 '((3 4) (1 2) ())) =>)
(test-solve (x) (conj (== x `(,? ,?)) (disks 3 x)) => '((x = ((1 2 3) ())))
                                                      '((x = (() (1 2 3)))))
(test-solve (x) (conj (== x `(,? ,? ,?)) (disks 4 x)) => '((x = ((1 2 3 4) () ())))
                                                         '((x = (() (1 2 3 4) ())))
                                                         '((x = (() () (1 2 3 4)))))
(test-solve (x) (disks 3 x) => '((x = ((1 2 3))))
                               '((x = ((1 2 3) ())))
                               '((x = (() (1 2 3))))
                               '((x = ((1 2 3) () ())))
                               '((x = (() (1 2 3) ())))
                               '((x = (() () (1 2 3)))))
(test-solve 5 (x) (disks x (list ? ? ? ?)) => '((x = 4))
                                              '((x = 4))
                                              '((x = 4))
                                              '((x = 4))
                                              '((x = 5)))
(test-solve 5 (x) (disks x `(() () ,? ())) => '((x = 4))
                                              '((x = 5))
                                              '((x = 6))
                                              '((x = 7))
                                              '((x = 8)))
(test-solve 21 (x y) (disks x y) => '((x = 1) (y = ((1))))
                                    '((x = 2) (y = ((1 2))))
                                    '((x = 2) (y = ((1 2) ())))
                                    '((x = 2) (y = (() (1 2))))
                                    '((x = 3) (y = ((1 2 3))))
                                    '((x = 3) (y = ((1 2 3) ())))
                                    '((x = 3) (y = (() (1 2 3))))
                                    '((x = 3) (y = ((1 2 3) () ())))
                                    '((x = 3) (y = (() (1 2 3) ())))
                                    '((x = 3) (y = (() () (1 2 3))))
                                    '((x = 4) (y = ((1 2 3 4))))
                                    '((x = 4) (y = ((1 2 3 4) ())))
                                    '((x = 4) (y = (() (1 2 3 4))))
                                    '((x = 4) (y = ((1 2 3 4) () ())))
                                    '((x = 4) (y = (() (1 2 3 4) ())))
                                    '((x = 4) (y = (() () (1 2 3 4))))
                                    '((x = 4) (y = ((1 2 3 4) () () ())))
                                    '((x = 4) (y = (() (1 2 3 4) () ())))
                                    '((x = 4) (y = (() () (1 2 3 4) ())))
                                    '((x = 4) (y = (() () () (1 2 3 4))))
                                    '((x = 5) (y = ((1 2 3 4 5)))))

(define (hanoi amount-rods amount-disks moves)
  ; TODO: This is too procedural-seeming.  How could it be more declarative/logical?
  (vars (initial)
    (conj
      ; Initial state, before first move.
      (== `(,initial . ,?) moves)
      (rods amount-rods initial)
      (disks amount-disks initial)

      (let move ((curr initial)
                 (moves moves)
                 (prev '()))
        ; All the possibilities from a state.
        (vars (moves* prev*)
          (conj
            (== `(,curr . ,moves*) moves)
            (== prev* `(,curr . ,prev))

            (let top-disk ((preceeding-rods '())
                           (remaining-rods curr))
              ; The possibilities of moving a top disk.
              (vars (rod succ)
                (conj
                  (== `(,rod . ,succ) remaining-rods)
                  (disj
                    ; The possibilities of moving the disk to one of the other rods.
                    (vars (disk rod* new psz ssz new-prec new-succ j others new-others)
                      (conj
                        (== `(,disk . ,rod*) rod)
                        (rods amount-rods new)
                        (size preceeding-rods psz)
                        (size succ ssz)
                        (size new-prec psz)
                        (size new-succ ssz)
                        (concat new-prec `(,rod*) j)
                        (concat j new-succ new)
                        (concat preceeding-rods succ others)
                        (concat new-prec new-succ new-others)

                        (let put-on ((others others)
                                     (new-others new-others))
                          (vars (o or n nr)
                            (conj (== `(,o . ,or) others)
                                  (== `(,n . ,nr) new-others)
                                  (disj
                                    ; The disk on this rod, and the others unchanged.
                                    (conj
                                      ; The rod must be allowed.
                                      (disj (== o '()) ; empty rod
                                            (vars (d)
                                              ; The moved disk must be smaller.  (This also
                                              ; excludes the rod the disk is from.)
                                              (conj (== `(,d . ,?) o)
                                                    (less disk d))))
                                      (== n `(,disk . ,o))
                                      (== nr or))
                                    ; This rod unchanged, and the disk on the others.
                                    (conj (== n o)
                                          (put-on or nr))))))
                        ; New move must not have been done already.
                        (neg (in new prev*))
                        (disj
                          ; A final state: disks on one rod, and no more moves.
                          (conj (disks amount-disks new)
                                (== moves* `(,new)))
                          ; The possibilities from a new non-final state.
                          (conj (neg (disks amount-disks new))
                                (move new moves* prev*)))))
                    ; The other possibilities from moving other top disks.
                    (vars (c)
                      (conj (concat preceeding-rods `(,rod) c)
                            (top-disk c succ)))))))))))))

(test-solve (x) (hanoi 2 2 x) =>)
(test-solve (x) (vars (z r)
                    (conj (less z 9)
                          (size x z)
                          (hanoi 3 3 x)
                          (== `((,? . ,r) . ,?) x)
                          (all '() r)))
            => '((x = (((1 2 3) () ())
                       ((2 3) (1) ())
                       ((3) (1) (2))
                       ((3) () (1 2))
                       (() (3) (1 2))
                       ((1) (3) (2))
                       ((1) (2 3) ())
                       (() (1 2 3) ()))))
               '((x = (((1 2 3) () ())
                       ((2 3) () (1))
                       ((3) (2) (1))
                       ((3) (1 2) ())
                       (() (1 2) (3))
                       ((1) (2) (3))
                       ((1) () (2 3))
                       (() () (1 2 3))))))
(check (length (solve (x) (hanoi 3 3 x))) => 7776)




(check-report)
